<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROHSA-GPU: algo_rohsa Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROHSA-GPU
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classalgo__rohsa.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classalgo__rohsa-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">algo_rohsa Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class concerns the ROHSA algorithm and the optimization algorithm.  
 <a href="classalgo__rohsa.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="algo__rohsa_8hpp_source.html">algo_rohsa.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b593414ce1b42a9cc3ffee3ee22107b"><td class="memItemLeft" align="right" valign="top"><a id="a4b593414ce1b42a9cc3ffee3ee22107b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>algo_rohsa</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, <a class="el" href="classhypercube.html">hypercube</a> &amp;Hypercube)</td></tr>
<tr class="separator:a4b593414ce1b42a9cc3ffee3ee22107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1f979d2d06d95b4a1ce27eb729c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54">descente</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;<a class="el" href="classalgo__rohsa.html#af2ef2dcbbdb1441eedaa4792ba125c3f">grid_params</a>, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;<a class="el" href="classalgo__rohsa.html#a3d92b6531fc9786a202e65c4a069ae28">fit_params</a>)</td></tr>
<tr class="memdesc:a91e1f979d2d06d95b4a1ce27eb729c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecewise spatially averaged array from the data extracted from the FITS file, then we compute the standard deviation map along each spatial position, we set the upper and lower boundaries and we solve iteratively the problem using L-BFGS-B-C, finally, we project the result onto a higher resolution grid. <br  />
  <a href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54">More...</a><br /></td></tr>
<tr class="separator:a91e1f979d2d06d95b4a1ce27eb729c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803c556cae0de92a8ae301fb870717f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a803c556cae0de92a8ae301fb870717f0">descente_sans_regu</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;<a class="el" href="classalgo__rohsa.html#af2ef2dcbbdb1441eedaa4792ba125c3f">grid_params</a>, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;<a class="el" href="classalgo__rohsa.html#a3d92b6531fc9786a202e65c4a069ae28">fit_params</a>)</td></tr>
<tr class="memdesc:a803c556cae0de92a8ae301fb870717f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54" title="Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecew...">descente()</a> but without regularization.  <a href="classalgo__rohsa.html#a803c556cae0de92a8ae301fb870717f0">More...</a><br /></td></tr>
<tr class="separator:a803c556cae0de92a8ae301fb870717f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00faa8093d025ec0b2ed3a8658d74f0c"><td class="memItemLeft" align="right" valign="top"><a id="a00faa8093d025ec0b2ed3a8658d74f0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a00faa8093d025ec0b2ed3a8658d74f0c">convolution_2D_mirror</a> (const <a class="el" href="classparameters.html">parameters</a> &amp;M, const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;image, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;conv, int dim_y, int dim_x, int dim_k)</td></tr>
<tr class="memdesc:a00faa8093d025ec0b2ed3a8658d74f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D convolutions needed for the regularization (for std::vectors) <br /></td></tr>
<tr class="separator:a00faa8093d025ec0b2ed3a8658d74f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d182a100ecbd2728faf509c60644e7"><td class="memItemLeft" align="right" valign="top"><a id="a55d182a100ecbd2728faf509c60644e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a55d182a100ecbd2728faf509c60644e7">convolution_2D_mirror_flat</a> (const <a class="el" href="classparameters.html">parameters</a> &amp;M, double *image, double *&amp;conv, int dim_y, int dim_x, int dim_k)</td></tr>
<tr class="memdesc:a55d182a100ecbd2728faf509c60644e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D convolutions needed for the regularization (for double flattened arrays) <br /></td></tr>
<tr class="separator:a55d182a100ecbd2728faf509c60644e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db4f71828670c9bb1e53df35b506d3e"><td class="memItemLeft" align="right" valign="top"><a id="a6db4f71828670c9bb1e53df35b506d3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a6db4f71828670c9bb1e53df35b506d3e">convolution_2D_mirror_flat</a> (const <a class="el" href="classparameters.html">parameters</a> &amp;M, float *image, float *&amp;conv, int dim_y, int dim_x, int dim_k, float temps_transfert, float temps_mirroirs)</td></tr>
<tr class="memdesc:a6db4f71828670c9bb1e53df35b506d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D convolutions needed for the regularization (for float flattened arrays) <br /></td></tr>
<tr class="separator:a6db4f71828670c9bb1e53df35b506d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932db416b95172f2c08685ef221df1be"><td class="memItemLeft" align="right" valign="top"><a id="a932db416b95172f2c08685ef221df1be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ravel_2D</b> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;map, std::vector&lt; double &gt; &amp;vector, int dim_y, int dim_x)</td></tr>
<tr class="separator:a932db416b95172f2c08685ef221df1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a14e9ef2ae075d73dea4cab0487b049"><td class="memItemLeft" align="right" valign="top"><a id="a2a14e9ef2ae075d73dea4cab0487b049"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ravel_3D</b> (const std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double vector[], int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a2a14e9ef2ae075d73dea4cab0487b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22da7dcc810acf9fc57abf0f997f44d6"><td class="memItemLeft" align="right" valign="top"><a id="a22da7dcc810acf9fc57abf0f997f44d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ravel_3D</b> (const std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, std::vector&lt; double &gt; &amp;vector, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a22da7dcc810acf9fc57abf0f997f44d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459f536c47c34bcd7ffce1d524e8f5b9"><td class="memItemLeft" align="right" valign="top"><a id="a459f536c47c34bcd7ffce1d524e8f5b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ravel_3D_bis</b> (const std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double vector[], int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a459f536c47c34bcd7ffce1d524e8f5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ce9637ae91e9877af4be403f1eb97a"><td class="memItemLeft" align="right" valign="top"><a id="ad3ce9637ae91e9877af4be403f1eb97a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ravel_3D_abs</b> (const std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, const std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube_abs, std::vector&lt; double &gt; &amp;vector, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:ad3ce9637ae91e9877af4be403f1eb97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8557b6f607d40f13cae2463f329993"><td class="memItemLeft" align="right" valign="top"><a id="a4e8557b6f607d40f13cae2463f329993"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unravel_3D</b> (const std::vector&lt; double &gt; &amp;vector, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a4e8557b6f607d40f13cae2463f329993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3532aee0599dff3ad4f3ccb5aa3e034c"><td class="memItemLeft" align="right" valign="top"><a id="a3532aee0599dff3ad4f3ccb5aa3e034c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unravel_3D</b> (double vector[], std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a3532aee0599dff3ad4f3ccb5aa3e034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a6ddd07d76a3ceb3c9c01a5f7feacf"><td class="memItemLeft" align="right" valign="top"><a id="ad6a6ddd07d76a3ceb3c9c01a5f7feacf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unravel_3D_with_formula_transpose_xy</b> (double vector[], std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:ad6a6ddd07d76a3ceb3c9c01a5f7feacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90e08f2cc222246c7b241f30912bdc"><td class="memItemLeft" align="right" valign="top"><a id="a8f90e08f2cc222246c7b241f30912bdc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unravel_3D_T</b> (double vector[], std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a8f90e08f2cc222246c7b241f30912bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a315a114352c78ce0297d2bdc3ea1cd"><td class="memItemLeft" align="right" valign="top"><a id="a8a315a114352c78ce0297d2bdc3ea1cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unravel_3D_abs</b> (const std::vector&lt; double &gt; &amp;vector, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube_abs, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int dim_v, int dim_y, int dim_x)</td></tr>
<tr class="separator:a8a315a114352c78ce0297d2bdc3ea1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9790e871874c0c83e5c789e5a3fbfef0"><td class="memItemLeft" align="right" valign="top"><a id="a9790e871874c0c83e5c789e5a3fbfef0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Std</b> (const std::vector&lt; double &gt; &amp;array)</td></tr>
<tr class="separator:a9790e871874c0c83e5c789e5a3fbfef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095f2a922386b6ef5a26119a22fd7080"><td class="memItemLeft" align="right" valign="top"><a id="a095f2a922386b6ef5a26119a22fd7080"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mean</b> (const std::vector&lt; double &gt; &amp;array)</td></tr>
<tr class="separator:a095f2a922386b6ef5a26119a22fd7080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fda7e18fab2a0ff2ab67c01bef467b"><td class="memItemLeft" align="right" valign="top"><a id="a36fda7e18fab2a0ff2ab67c01bef467b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>std_2D</b> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;map, int dim_y, int dim_x)</td></tr>
<tr class="separator:a36fda7e18fab2a0ff2ab67c01bef467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a4c870ad162b992e71b8a0c516074c"><td class="memItemLeft" align="right" valign="top"><a id="a42a4c870ad162b992e71b8a0c516074c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>max_2D</b> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;map, int dim_y, int dim_x)</td></tr>
<tr class="separator:a42a4c870ad162b992e71b8a0c516074c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974eefcd1d4820bf5e48a575117ece89"><td class="memItemLeft" align="right" valign="top"><a id="a974eefcd1d4820bf5e48a575117ece89"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mean_2D</b> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;map, int dim_y, int dim_x)</td></tr>
<tr class="separator:a974eefcd1d4820bf5e48a575117ece89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88496529c1e2d6d7c81bc7ae9e0825"><td class="memItemLeft" align="right" valign="top"><a id="abf88496529c1e2d6d7c81bc7ae9e0825"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>std_spectrum</b> (int dim_x, int dim_y, int dim_v)</td></tr>
<tr class="separator:abf88496529c1e2d6d7c81bc7ae9e0825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f162489471abc71a4845d437e2d06d"><td class="memItemLeft" align="right" valign="top"><a id="ae1f162489471abc71a4845d437e2d06d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mean_spectrum</b> (int dim_x, int dim_y, int dim_v)</td></tr>
<tr class="separator:ae1f162489471abc71a4845d437e2d06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89b9c32ff238b18dc559c17822047df"><td class="memItemLeft" align="right" valign="top"><a id="ac89b9c32ff238b18dc559c17822047df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>max_spectrum</b> (int dim_x, int dim_y, int dim_v)</td></tr>
<tr class="separator:ac89b9c32ff238b18dc559c17822047df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ecfd54a63b32f72b71c64f33b02fbb"><td class="memItemLeft" align="right" valign="top"><a id="a67ecfd54a63b32f72b71c64f33b02fbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>max_spectrum_norm</b> (int dim_x, int dim_y, int dim_v, double norm_value)</td></tr>
<tr class="separator:a67ecfd54a63b32f72b71c64f33b02fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73e186a5be67a64052790e3de34adba"><td class="memItemLeft" align="right" valign="top"><a id="ad73e186a5be67a64052790e3de34adba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#ad73e186a5be67a64052790e3de34adba">init_bounds</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; double &gt; line, int n_gauss_local, std::vector&lt; double &gt; &amp;lb, std::vector&lt; double &gt; &amp;ub, bool _init)</td></tr>
<tr class="memdesc:ad73e186a5be67a64052790e3de34adba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets boundary conditions for spectrum. <br /></td></tr>
<tr class="separator:ad73e186a5be67a64052790e3de34adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ebaacc6a117030dc722dbd2b1d71ae"><td class="memItemLeft" align="right" valign="top"><a id="a96ebaacc6a117030dc722dbd2b1d71ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a96ebaacc6a117030dc722dbd2b1d71ae">mean_array</a> (int power, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;mean_array_)</td></tr>
<tr class="memdesc:a96ebaacc6a117030dc722dbd2b1d71ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a piecewise spatially averaged array for multiresolution. <br /></td></tr>
<tr class="separator:a96ebaacc6a117030dc722dbd2b1d71ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7282e04c8e3d994baba96f5943b059d7"><td class="memItemLeft" align="right" valign="top"><a id="a7282e04c8e3d994baba96f5943b059d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a7282e04c8e3d994baba96f5943b059d7">init_spectrum</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; double &gt; &amp;line, std::vector&lt; double &gt; &amp;params)</td></tr>
<tr class="memdesc:a7282e04c8e3d994baba96f5943b059d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes spectrum (called during first iteration) <br /></td></tr>
<tr class="separator:a7282e04c8e3d994baba96f5943b059d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9e812e31df7d2692ceb8f0792de2a5"><td class="memItemLeft" align="right" valign="top"><a id="aac9e812e31df7d2692ceb8f0792de2a5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#aac9e812e31df7d2692ceb8f0792de2a5">model_function</a> (int x, double a, double m, double s)</td></tr>
<tr class="memdesc:aac9e812e31df7d2692ceb8f0792de2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns exp(-(x-m)^2/(2*s^2)) <br /></td></tr>
<tr class="separator:aac9e812e31df7d2692ceb8f0792de2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d25fe0cc707a7765c9d219d3637a9f"><td class="memItemLeft" align="right" valign="top"><a id="ab9d25fe0cc707a7765c9d219d3637a9f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#ab9d25fe0cc707a7765c9d219d3637a9f">minloc</a> (std::vector&lt; double &gt; &amp;tab)</td></tr>
<tr class="memdesc:ab9d25fe0cc707a7765c9d219d3637a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">argmin function for a std::vector type array <br /></td></tr>
<tr class="separator:ab9d25fe0cc707a7765c9d219d3637a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9da2931b907b1410dd5a36975d9991"><td class="memItemLeft" align="right" valign="top"><a id="aea9da2931b907b1410dd5a36975d9991"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#aea9da2931b907b1410dd5a36975d9991">minimize_spec</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, long n, long m, std::vector&lt; double &gt; &amp;x_v, std::vector&lt; double &gt; &amp;lb_v, int n_gauss_i, std::vector&lt; double &gt; &amp;ub_v, std::vector&lt; double &gt; &amp;line_v)</td></tr>
<tr class="memdesc:aea9da2931b907b1410dd5a36975d9991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the optimization problem during the first iteration, it calls the L-BFGS-B black box. <br /></td></tr>
<tr class="separator:aea9da2931b907b1410dd5a36975d9991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38d6954e64c3b309e03390aa4d9d554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554">minimize</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, long n, long m, std::vector&lt; double &gt; &amp;beta, std::vector&lt; double &gt; &amp;lb_v, std::vector&lt; double &gt; &amp;ub_v, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig, int dim_x, int dim_y, int dim_v, double *cube_flattened)</td></tr>
<tr class="memdesc:ac38d6954e64c3b309e03390aa4d9d554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine solving the optimization problem. <br  />
  <a href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554">More...</a><br /></td></tr>
<tr class="separator:ac38d6954e64c3b309e03390aa4d9d554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1ef17f061c77fcf132c10183a3fb6"><td class="memItemLeft" align="right" valign="top"><a id="a6fa1ef17f061c77fcf132c10183a3fb6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a6fa1ef17f061c77fcf132c10183a3fb6">myresidual</a> (double params[], double line[], std::vector&lt; double &gt; &amp;residual, int n_gauss_i)</td></tr>
<tr class="memdesc:a6fa1ef17f061c77fcf132c10183a3fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the residual along a spatial position (for a double array) <br /></td></tr>
<tr class="separator:a6fa1ef17f061c77fcf132c10183a3fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fa629ed436011921ea3f9e33999742"><td class="memItemLeft" align="right" valign="top"><a id="a10fa629ed436011921ea3f9e33999742"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a10fa629ed436011921ea3f9e33999742">myresidual</a> (std::vector&lt; double &gt; &amp;params, std::vector&lt; double &gt; &amp;line, std::vector&lt; double &gt; &amp;residual, int n_gauss_i)</td></tr>
<tr class="memdesc:a10fa629ed436011921ea3f9e33999742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the residual along a spatial position (for an std::vector) <br /></td></tr>
<tr class="separator:a10fa629ed436011921ea3f9e33999742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b21a1b489da03e14070aa2d147020d"><td class="memItemLeft" align="right" valign="top"><a id="ab6b21a1b489da03e14070aa2d147020d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tab_from_1Dvector_to_double</b> (std::vector&lt; double &gt; vect)</td></tr>
<tr class="separator:ab6b21a1b489da03e14070aa2d147020d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a808ca88cd6294f932cde362304896"><td class="memItemLeft" align="right" valign="top"><a id="ad7a808ca88cd6294f932cde362304896"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myfunc_spec</b> (std::vector&lt; double &gt; &amp;residual)</td></tr>
<tr class="separator:ad7a808ca88cd6294f932cde362304896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fdd8a706306dac03acd3993ff8f231"><td class="memItemLeft" align="right" valign="top"><a id="af7fdd8a706306dac03acd3993ff8f231"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#af7fdd8a706306dac03acd3993ff8f231">mygrad_spec</a> (double gradient[], std::vector&lt; double &gt; &amp;residual, double params[], int n_gauss_i)</td></tr>
<tr class="memdesc:af7fdd8a706306dac03acd3993ff8f231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient for first iteration (called in minimize_spec) <br /></td></tr>
<tr class="separator:af7fdd8a706306dac03acd3993ff8f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb400769e028b3b1cb9795fd67a76b73"><td class="memItemLeft" align="right" valign="top"><a id="aeb400769e028b3b1cb9795fd67a76b73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#aeb400769e028b3b1cb9795fd67a76b73">upgrade</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;params, int power)</td></tr>
<tr class="memdesc:aeb400769e028b3b1cb9795fd67a76b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares boundary conditions and calls the minimize function. This function is used for the 1D case or if regularization is not activated. <br /></td></tr>
<tr class="separator:aeb400769e028b3b1cb9795fd67a76b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90188b650c902d26adc5848297c8b49d"><td class="memItemLeft" align="right" valign="top"><a id="a90188b650c902d26adc5848297c8b49d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a90188b650c902d26adc5848297c8b49d">go_up_level</a> (std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;<a class="el" href="classalgo__rohsa.html#a3d92b6531fc9786a202e65c4a069ae28">fit_params</a>)</td></tr>
<tr class="memdesc:a90188b650c902d26adc5848297c8b49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects the solution to the next resolution level. <br /></td></tr>
<tr class="separator:a90188b650c902d26adc5848297c8b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9507123ce878c11016b924c08c57dad5"><td class="memItemLeft" align="right" valign="top"><a id="a9507123ce878c11016b924c08c57dad5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a9507123ce878c11016b924c08c57dad5">set_stdmap</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int lb, int ub)</td></tr>
<tr class="memdesc:a9507123ce878c11016b924c08c57dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the standard deviation map for every spatial position. <br /></td></tr>
<tr class="separator:a9507123ce878c11016b924c08c57dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034f5cba90025d96cb4087301f5de7d6"><td class="memItemLeft" align="right" valign="top"><a id="a034f5cba90025d96cb4087301f5de7d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_stdmap_transpose</b> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, int lb, int ub)</td></tr>
<tr class="separator:a034f5cba90025d96cb4087301f5de7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef915659d10fb3ebbde1e7462000c9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#aef915659d10fb3ebbde1e7462000c9b0">update</a> (<a class="el" href="classparameters.html">parameters</a> &amp;M, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube_avgd_or_data, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;params, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, int indice_x, int indice_y, int indice_v, std::vector&lt; double &gt; &amp;b_params)</td></tr>
<tr class="memdesc:aef915659d10fb3ebbde1e7462000c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">We prepare the boundary conditions and we call the routine that will make the model fit the data. <br  />
  <a href="classalgo__rohsa.html#aef915659d10fb3ebbde1e7462000c9b0">More...</a><br /></td></tr>
<tr class="separator:aef915659d10fb3ebbde1e7462000c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62814fa3e5efb0f2e280be4921024dd"><td class="memItemLeft" align="right" valign="top"><a id="af62814fa3e5efb0f2e280be4921024dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_vector</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:af62814fa3e5efb0f2e280be4921024dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f499686bdcd2dd60d193778ebcb730"><td class="memItemLeft" align="right" valign="top"><a id="ad6f499686bdcd2dd60d193778ebcb730"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_old_archive</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:ad6f499686bdcd2dd60d193778ebcb730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e88ae874908d75aead7b77fe14c2f"><td class="memItemLeft" align="right" valign="top"><a id="ac91e88ae874908d75aead7b77fe14c2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_sep</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:ac91e88ae874908d75aead7b77fe14c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95966672669e9ed0dd761c3669c4343"><td class="memItemLeft" align="right" valign="top"><a id="ac95966672669e9ed0dd761c3669c4343"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_test</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:ac95966672669e9ed0dd761c3669c4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dd9acb0713555597a25d62320ce53b"><td class="memItemLeft" align="right" valign="top"><a id="a36dd9acb0713555597a25d62320ce53b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_naive</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a36dd9acb0713555597a25d62320ce53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d395c1a9aa7020e725012b2b263e05"><td class="memItemLeft" align="right" valign="top"><a id="a75d395c1a9aa7020e725012b2b263e05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_fast</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a75d395c1a9aa7020e725012b2b263e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b98059cc9dcbbf1bd38566c1f0aaf1"><td class="memItemLeft" align="right" valign="top"><a id="a93b98059cc9dcbbf1bd38566c1f0aaf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_fast_without_regul</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a93b98059cc9dcbbf1bd38566c1f0aaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd75b1c915166fcb0c72c563e6ea487"><td class="memItemLeft" align="right" valign="top"><a id="a6fd75b1c915166fcb0c72c563e6ea487"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_cuda_L</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig, double *cube_flattened)</td></tr>
<tr class="separator:a6fd75b1c915166fcb0c72c563e6ea487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2748b7f797eca080da868636a513522"><td class="memItemLeft" align="right" valign="top"><a id="aa2748b7f797eca080da868636a513522"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_cuda_L_deux_tiers</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig, double *cube_flattened)</td></tr>
<tr class="separator:aa2748b7f797eca080da868636a513522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2432291b3d528a16252b377a8a0440"><td class="memItemLeft" align="right" valign="top"><a id="a1e2432291b3d528a16252b377a8a0440"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_cuda_L_debug</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a1e2432291b3d528a16252b377a8a0440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bfef688648ee4e7be1e98802ed6987"><td class="memItemLeft" align="right" valign="top"><a id="a69bfef688648ee4e7be1e98802ed6987"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_cuda_L_2</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a69bfef688648ee4e7be1e98802ed6987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13596df95325208f6d20e1dded49ee28"><td class="memItemLeft" align="right" valign="top"><a id="a13596df95325208f6d20e1dded49ee28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_cuda_L_2_2Bverified</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a13596df95325208f6d20e1dded49ee28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a091215204d0bca079252b65fc3cfd1"><td class="memItemLeft" align="right" valign="top"><a id="a3a091215204d0bca079252b65fc3cfd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_omp</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a3a091215204d0bca079252b65fc3cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576f0e3246c0471dd0ab9a1c3792821f"><td class="memItemLeft" align="right" valign="top"><a id="a576f0e3246c0471dd0ab9a1c3792821f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>f_g_cube_omp_without_regul</b> (<a class="el" href="classparameters.html">parameters</a> &amp;M, double &amp;f, double g[], int n, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;cube, double beta[], int indice_v, int indice_y, int indice_x, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;std_map, std::vector&lt; double &gt; &amp;mean_amp, std::vector&lt; double &gt; &amp;mean_mu, std::vector&lt; double &gt; &amp;mean_sig)</td></tr>
<tr class="separator:a576f0e3246c0471dd0ab9a1c3792821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cab8e7177133cd35931fefa4b9a0f6b"><td class="memItemLeft" align="right" valign="top"><a id="a4cab8e7177133cd35931fefa4b9a0f6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reshape_down</b> (std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;tab1, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;tab2)</td></tr>
<tr class="separator:a4cab8e7177133cd35931fefa4b9a0f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcb263b7fddcb618d9690d0762899ae"><td class="memItemLeft" align="right" valign="top"><a id="addcb263b7fddcb618d9690d0762899ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#addcb263b7fddcb618d9690d0762899ae">mean_parameters</a> (std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;params)</td></tr>
<tr class="memdesc:addcb263b7fddcb618d9690d0762899ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine prints the mean value of each of the \( 3 n\_gauss \) gaussian parameters. <br /></td></tr>
<tr class="separator:addcb263b7fddcb618d9690d0762899ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af2ef2dcbbdb1441eedaa4792ba125c3f"><td class="memItemLeft" align="right" valign="top"><a id="af2ef2dcbbdb1441eedaa4792ba125c3f"></a>
std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#af2ef2dcbbdb1441eedaa4792ba125c3f">grid_params</a></td></tr>
<tr class="memdesc:af2ef2dcbbdb1441eedaa4792ba125c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array containing the gaussian parameters \(\lambda, \mu, \sigma \) depending on the spatial position. Dimensions : It is a \( 3 n\_gauss \times dim\_y \times dim\_x \). <br /></td></tr>
<tr class="separator:af2ef2dcbbdb1441eedaa4792ba125c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d92b6531fc9786a202e65c4a069ae28"><td class="memItemLeft" align="right" valign="top"><a id="a3d92b6531fc9786a202e65c4a069ae28"></a>
std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a3d92b6531fc9786a202e65c4a069ae28">fit_params</a></td></tr>
<tr class="memdesc:a3d92b6531fc9786a202e65c4a069ae28"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as grid_params (gaussian parameters) but this array is used through multiresolution. Dimensions : \( 3 n\_gauss \times 2^k \times 2^k \) for \( 0 &lt; k &lt; n\_side \). <br /></td></tr>
<tr class="separator:a3d92b6531fc9786a202e65c4a069ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ade44d2e75c9ef7918d2a1098357c48"><td class="memItemLeft" align="right" valign="top"><a id="a9ade44d2e75c9ef7918d2a1098357c48"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalgo__rohsa.html#a9ade44d2e75c9ef7918d2a1098357c48">cube_or_dat_flattened</a></td></tr>
<tr class="memdesc:a9ade44d2e75c9ef7918d2a1098357c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data flattened at each iteration. Because of the multiresolution process, it has to be computed at each iteration. <br /></td></tr>
<tr class="separator:a9ade44d2e75c9ef7918d2a1098357c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class concerns the ROHSA algorithm and the optimization algorithm. </p>
<p>The section below presents the attributes of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_params</td><td>is a 3D array containing the gaussian parameters \(\lambda, \mu, \sigma \) depending on the spatial position. It is a \( 3 n\_gauss \times dim\_y \times dim\_x \) dimensional array. </td></tr>
    <tr><td class="paramname">fit_params</td><td>is similar to grid_params (gaussian parameters) but its dimensions varies through multiresolution. It is a \( 3 n\_gauss \times 2^k \times 2^k \) for \( 0 &lt; k &lt; n\_side \) dimensional array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algo__rohsa_8hpp_source.html#l00060">60</a> of file <a class="el" href="algo__rohsa_8hpp_source.html">algo_rohsa.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a91e1f979d2d06d95b4a1ce27eb729c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e1f979d2d06d95b4a1ce27eb729c54">&#9670;&nbsp;</a></span>descente()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void algo_rohsa::descente </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fit_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecewise spatially averaged array from the data extracted from the FITS file, then we compute the standard deviation map along each spatial position, we set the upper and lower boundaries and we solve iteratively the problem using L-BFGS-B-C, finally, we project the result onto a higher resolution grid. <br  />
 </p>
<p>The section below presents the attributes of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>is an object, its attributes are the variables whose values are chosen by the user in parameters.txt, these are variables related to the data structure, the gaussian model and the black box of L-BFGS-B-C used in the <a class="el" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554" title="Routine solving the optimization problem.">minimize()</a> function. </td></tr>
    <tr><td class="paramname">Hypercube</td><td>is an object containing the attributes data and cube. "data" is the array extracted from the FITS file and truncated because of the unexploitable spectral ranges of the data ; "cube" is an array whose side is a power of 2 and containing the data array.</td></tr>
  </table>
  </dd>
</dl>
<p>Since we don't want to make useless computations, we use cube (and fit_params) until the last level of multiresolution. When we reach the last level, we use data (and grid_params) which has the original dimensions of the hypercube (after truncation on the spectral dimension). <br  />
 main loop for the multiresolution process </p>

<p class="definition">Definition at line <a class="el" href="algo__rohsa_8cpp_source.html#l00087">87</a> of file <a class="el" href="algo__rohsa_8cpp_source.html">algo_rohsa.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classalgo__rohsa_a91e1f979d2d06d95b4a1ce27eb729c54_cgraph.png" border="0" usemap="#classalgo__rohsa_a91e1f979d2d06d95b4a1ce27eb729c54_cgraph" alt=""/></div>
<map name="classalgo__rohsa_a91e1f979d2d06d95b4a1ce27eb729c54_cgraph" id="classalgo__rohsa_a91e1f979d2d06d95b4a1ce27eb729c54_cgraph">
<area shape="rect" title="Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecew..." alt="" coords="5,157,165,184"/>
<area shape="rect" href="classalgo__rohsa.html#a90188b650c902d26adc5848297c8b49d" title="Projects the solution to the next resolution level." alt="" coords="234,5,413,32"/>
<area shape="rect" href="classalgo__rohsa.html#a7282e04c8e3d994baba96f5943b059d7" title="Initializes spectrum (called during first iteration)" alt="" coords="228,157,419,184"/>
<area shape="rect" href="classalgo__rohsa.html#a96ebaacc6a117030dc722dbd2b1d71ae" title="Computes a piecewise spatially averaged array for multiresolution." alt="" coords="234,208,413,235"/>
<area shape="rect" href="classalgo__rohsa.html#addcb263b7fddcb618d9690d0762899ae" title="This routine prints the mean value of each of the &#160;gaussian parameters." alt="" coords="213,259,433,285"/>
<area shape="rect" href="classalgo__rohsa.html#a9507123ce878c11016b924c08c57dad5" title="Computes the standard deviation map for every spatial position." alt="" coords="235,309,412,336"/>
<area shape="rect" href="classalgo__rohsa.html#aef915659d10fb3ebbde1e7462000c9b0" title="We prepare the boundary conditions and we call the routine that will make the model fit the data." alt="" coords="250,56,397,83"/>
<area shape="rect" href="classalgo__rohsa.html#aeb400769e028b3b1cb9795fd67a76b73" title="Prepares boundary conditions and calls the minimize function. This function is used for the 1D case o..." alt="" coords="246,107,401,133"/>
<area shape="rect" href="classalgo__rohsa.html#ad73e186a5be67a64052790e3de34adba" title="Sets boundary conditions for spectrum." alt="" coords="493,81,669,108"/>
<area shape="rect" href="classalgo__rohsa.html#aea9da2931b907b1410dd5a36975d9991" title="Solves the optimization problem during the first iteration, it calls the L&#45;BFGS&#45;B black box." alt="" coords="481,132,680,159"/>
<area shape="rect" href="classalgo__rohsa.html#aac9e812e31df7d2692ceb8f0792de2a5" title="returns exp(&#45;(x&#45;m)^2/(2*s^2))" alt="" coords="964,157,1167,184"/>
<area shape="rect" href="classalgo__rohsa.html#ab9d25fe0cc707a7765c9d219d3637a9f" title="argmin function for a std::vector type array" alt="" coords="508,233,653,260"/>
<area shape="rect" href="classalgo__rohsa.html#af7fdd8a706306dac03acd3993ff8f231" title="Gradient for first iteration (called in minimize_spec)" alt="" coords="728,81,916,108"/>
<area shape="rect" href="classalgo__rohsa.html#a6fa1ef17f061c77fcf132c10183a3fb6" title="Computes the residual along a spatial position (for a double array)" alt="" coords="735,132,909,159"/>
<area shape="rect" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554" title="Routine solving the optimization problem." alt="" coords="499,31,662,57"/>
</map>
</div>

</div>
</div>
<a id="a803c556cae0de92a8ae301fb870717f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803c556cae0de92a8ae301fb870717f0">&#9670;&nbsp;</a></span>descente_sans_regu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void algo_rohsa::descente_sans_regu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fit_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54" title="Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecew...">descente()</a> but without regularization. </p>
<p>main loop for the multiresolution without convolutions </p>

<p class="definition">Definition at line <a class="el" href="algo__rohsa_8cpp_source.html#l05003">5003</a> of file <a class="el" href="algo__rohsa_8cpp_source.html">algo_rohsa.cpp</a>.</p>

</div>
</div>
<a id="ac38d6954e64c3b309e03390aa4d9d554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38d6954e64c3b309e03390aa4d9d554">&#9670;&nbsp;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void algo_rohsa::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>std_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean_amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean_sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cube_flattened</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine solving the optimization problem. <br  />
 </p>
<p>Solves the optimization problem during one resolution level of multiresolution, it calls the L-BFGS-B black box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>is the flattened gaussian parameters array. It contains the maps of \( \lambda, \mu, \sigma \) and also \( m \), inserted in the last n_gauss indices of the array. Its length is therefore \( n\_beta = 3n\_gauss \times dim\_y \times dim\_x + n\_gauss \). We may write <b>beta</b> as \( ( \theta, m ) \), where \( \theta = \left ( \begin{bmatrix} \lambda_1 \\ \mu_1 \\ \sigma_1 \end{bmatrix} , \begin{bmatrix} \lambda_2 \\ \mu_2 \\ \sigma_2 \end{bmatrix}, ... , \begin{bmatrix} \lambda_{n\_gauss} \\ \mu_{n\_gauss} \\ \sigma_{n\_gauss} \end{bmatrix} \right) \) is a line vector of maps representing the gaussian parameters of each gaussian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>beta</b> \( \equiv ( \theta, m ) \) such as it solves the optimization problem below.</dd></dl>
<p class="formulaDsp">
\[ \begin{align*} \text{Minimize } J( \theta, m ) = \frac{1}{2} \sum_{\nu_z,\textbf{r}} \left( \frac{residual(\nu_z,\textbf{r})}{std\_map(\textbf{r })}\right)^2 &amp;+ \frac{1}{2} \sum_{n=1}^{n\_gauss} ( \lambda_a ||\textbf{D} a_n||_{L^2}^2 \\ &amp;+ \lambda_\mu ||\textbf{D} \mu_n||_{L^2}^2 \\ &amp;+ \lambda_\sigma ||\textbf{D} \sigma_n||_{L^2}^2 \\ &amp;+ \lambda_\sigma&#39; ||\sigma_n - m_n||_{L^2}^2 ) \end{align*} \]
</p>
<p>Where : <br  />
</p>
<p>\( residual \) is the difference between the model (sum of gaussians) and the cube. It is computed though the spatial and the spectral dimensions.</p>
<p><b>D</b> is a discrete derivative.</p>
<p>\( \lambda_a, \lambda_\mu, \lambda_\sigma \)&#160;and \( \lambda_\sigma&#39; \) are constant hyperparameters stored as attributes of the object \( M \).</p>
<p>\( n\_gauss \) is the number of gaussians.</p>
<p>\( \textbf{r} \) represents spatial coordinates.</p>
<p>\( \nu_z \) is the spectral dimension.</p>
<p>\( a_n, \mu_n \) and \( \sigma_n \) are maps of the gaussian parameters of the n-th gaussian.</p>
<p>The smoothness of the solution results from the terms (aligned to the right of the "+" sign) involving the convolutions. \( R(\theta,m) \) denotes these terms ( \( R\) for regularization).</p>
<p>L-BFGS-B approximates the solution with :</p>
<p class="formulaDsp">
\[ \begin{align*} \left\{ \begin{array}{ll} \theta_{k+1} = \theta_k - \alpha_k \textbf{H}_k^{-1} \nabla J(\theta_k, m_k)\\ \theta_0 = \theta_{initialization} \end{array} \right. \label{formulas} \end{align*} \]
</p>
<p> where \( \textbf{H}_k \) is a matrix and \( \alpha_k \) a real number. It stops when the algorithm reaches a maximum of iterations or if the projected gradient is small enough.</p>
<p>As we can see we need to compute the gradient of \( J \).</p>
<p class="formulaDsp">
\[ \nabla J(\theta, m) = \begin{bmatrix} \nabla_{\theta} residual(\theta) \times \frac{residual(\theta)}{(std\_map(\textbf{r }))^2} \\ 0 \end{bmatrix} + \begin{bmatrix} \nabla_{\theta} R(\theta,m)\\ \nabla_{m} R(\theta,m) \end{bmatrix} \]
</p>
<p>\( \nabla residual(\theta) \) is given by its litteral expression : </p><p class="formulaDsp">
\[ \nabla_{\theta} residual(\nu_z,\theta(\bf{r}))= \begin{bmatrix} exp\left( -\frac{(\nu_z-\mu_1(\bf{r}))^2}{2\sigma_1(\bf{r})^2} \right) \\ \frac{a_1(\nu_z-\mu_1(\bf{r}))}{\sigma_1(\bf{r})^2} exp\left( -\frac{(\nu_z-\mu_1(\bf{r}))^2}{2\sigma_1(\bf{r})^2} \right) \\ \frac{a_1(\nu_z-\mu_1(\bf{r}))^2}{\sigma_1(\bf{r})^3} exp\left( -\frac{(\nu_z-\mu_1(\bf{r}))^2}{2\sigma_1(\bf{r})^2} \right) \\ \vdots\\ exp\left( -\frac{(\nu_z-\mu_{n\_gauss}(\bf{r}))^2}{2\sigma_{n\_gauss}(\bf{r})^2} \right) \\ \frac{a_{n\_gauss}(\nu_z-\mu_{n\_gauss}(\bf{r}))}{\sigma_{n\_gauss}(\bf{r})^2} exp\left( -\frac{(\nu_z-\mu_{n\_gauss}(\bf{r}))^2}{2\sigma_{n\_gauss}(\bf{r})^2} \right) \\ \frac{a_{n\_gauss}(\nu_z-\mu_{n\_gauss}(\bf{r}))^2}{\sigma_{n\_gauss}(\bf{r})^3} exp\left( -\frac{(\nu_z-\mu_{n\_gauss}(\bf{r}))^2}{2\sigma_{n\_gauss}(\bf{r})^2} \right) \end{bmatrix} \]
</p>
<p>\( \nabla R(\theta,m) \) can be also expressed through a litteral expression : </p><p class="formulaDsp">
\[ \nabla_{\theta} R(\theta, m)= \begin{bmatrix} \lambda_a D^t D a_1 \\ \lambda_\mu D^t D \mu_1 \\ \lambda_\sigma D^t D \sigma_1 \\ \lambda&#39;_\sigma(\sigma_1-m_1)\\ \vdots\\ \lambda&#39;_\sigma(\sigma_{n\_gauss}-m_{n\_gauss}) \end{bmatrix} \]
</p>
<p class="formulaDsp">
\[ \nabla_{m} R(\theta, m)= \begin{bmatrix} -\sum_r \lambda&#39;_\sigma(\sigma_1-m_1) \\ \vdots\\ -\sum_r \lambda&#39;_\sigma(\sigma_{n\_gauss}-m_{n\_gauss}) \end{bmatrix} \]
</p>
<p>The function <b>setulb()</b> used as a black box corresponds to the computation of \( \theta_{k+1} \), the Hessian is approached using the M.m (set in parameters.txt) lasts results (hence the "L" in "L-BFGS" which stands for "limited memory"). The function <b>f_g_cube()</b> computes the gradient \( g = \nabla J(\theta, m) \) and a scalar named \( f \). </p>

<p class="definition">Definition at line <a class="el" href="algo__rohsa_8cpp_source.html#l03521">3521</a> of file <a class="el" href="algo__rohsa_8cpp_source.html">algo_rohsa.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classalgo__rohsa_ac38d6954e64c3b309e03390aa4d9d554_icgraph.png" border="0" usemap="#classalgo__rohsa_ac38d6954e64c3b309e03390aa4d9d554_icgraph" alt=""/></div>
<map name="classalgo__rohsa_ac38d6954e64c3b309e03390aa4d9d554_icgraph" id="classalgo__rohsa_ac38d6954e64c3b309e03390aa4d9d554_icgraph">
<area shape="rect" title="Routine solving the optimization problem." alt="" coords="408,5,571,32"/>
<area shape="rect" href="classalgo__rohsa.html#aef915659d10fb3ebbde1e7462000c9b0" title="We prepare the boundary conditions and we call the routine that will make the model fit the data." alt="" coords="213,5,360,32"/>
<area shape="rect" href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54" title="Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecew..." alt="" coords="5,5,165,32"/>
</map>
</div>

</div>
</div>
<a id="aef915659d10fb3ebbde1e7462000c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef915659d10fb3ebbde1e7462000c9b0">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void algo_rohsa::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cube_avgd_or_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>std_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indice_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indice_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indice_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We prepare the boundary conditions and we call the routine that will make the model fit the data. <br  />
 </p>
<dl class="section return"><dt>Returns</dt><dd><b>params</b> and <b>b_params</b> : 3D array of gaussian parameters and a 1D array representing an additionnal term of the cost function.</dd></dl>
<p>The section below presents the attributes of this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cube_avgd_or_data</td><td>is either the averaged cube array corresponding to a level of multiresolution or the data array (last level of multiresolution). </td></tr>
    <tr><td class="paramname">M</td><td>is an object, its attributes are the variables whose values are chosen by the user in parameters.txt, these are variables related to the data structure, the gaussian model and the black box of L-BFGS-B-C used in the <a class="el" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554" title="Routine solving the optimization problem.">minimize()</a> function. </td></tr>
    <tr><td class="paramname">std_map</td><td>is the standard deviation map computed from the cube</td></tr>
  </table>
  </dd>
</dl>
<p>Using <a class="el" href="classalgo__rohsa.html#ad73e186a5be67a64052790e3de34adba" title="Sets boundary conditions for spectrum.">init_bounds()</a> we prepare the upper and lower boundary conditions ub and lb. Every array is flattened. <b>We use "beta" as the flattened gaussian parameters array.</b> (Remark : We can afford these transformations because we haven't yet reached the optimization loop of <a class="el" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554" title="Routine solving the optimization problem.">minimize()</a> which calls L-BFGS-B-C.) Prepares boundary conditions and calls the minimize function. </p>

<p class="definition">Definition at line <a class="el" href="algo__rohsa_8cpp_source.html#l00444">444</a> of file <a class="el" href="algo__rohsa_8cpp_source.html">algo_rohsa.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_cgraph.png" border="0" usemap="#classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_cgraph" alt=""/></div>
<map name="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_cgraph" id="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_cgraph">
<area shape="rect" title="We prepare the boundary conditions and we call the routine that will make the model fit the data." alt="" coords="5,31,152,57"/>
<area shape="rect" href="classalgo__rohsa.html#ad73e186a5be67a64052790e3de34adba" title="Sets boundary conditions for spectrum." alt="" coords="200,5,376,32"/>
<area shape="rect" href="classalgo__rohsa.html#ac38d6954e64c3b309e03390aa4d9d554" title="Routine solving the optimization problem." alt="" coords="207,56,369,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_icgraph.png" border="0" usemap="#classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_icgraph" alt=""/></div>
<map name="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_icgraph" id="classalgo__rohsa_aef915659d10fb3ebbde1e7462000c9b0_icgraph">
<area shape="rect" title="We prepare the boundary conditions and we call the routine that will make the model fit the data." alt="" coords="213,5,360,32"/>
<area shape="rect" href="classalgo__rohsa.html#a91e1f979d2d06d95b4a1ce27eb729c54" title="Each iteration into the main loop corresponds to a resolution. At each iteration, we compute a piecew..." alt="" coords="5,5,165,32"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>inc/<a class="el" href="algo__rohsa_8hpp_source.html">algo_rohsa.hpp</a></li>
<li>src/CPP/<a class="el" href="algo__rohsa_8cpp_source.html">algo_rohsa.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classalgo__rohsa.html">algo_rohsa</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
